{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./node_modules/argv/index.js","webpack:///./node_modules/argv/lib/argv.js","webpack:///./src/bin/bin_vladnet.ts","webpack:///./src/bin/loadActions.ts","webpack:///./src/bin/normalizePaths.ts","webpack:///./src/nativeRequire.ts","webpack:///external \"fs\"","webpack:///external \"path\""],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA,iBAAiB,mBAAO,EAAE,sDAAe;;;;;;;;;;;;ACAzC,WAAW,mBAAO,EAAE,kBAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa,EAAE;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,SAAS,gBAAgB;;AAEzB;AACA,WAAW,mBAAmB;;AAE9B;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa,EAAE;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,sBAAsB,WAAW;AAC1D;;AAEA;AACA,2B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6BAA6B,WAAW;AACtE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,cAAc,yBAAyB,EAAE;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AA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","file":"bin_vladnet.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/bin/bin_vladnet.ts\");\n","module.exports = require( './lib/argv.js' );\n","var PATH = require( 'path' ),\n\ttoString = Object.prototype.toString,\n\trhome = /^\\~\\//,\n\trroot = /^\\//,\n\trlistcsv = /^(list|csv)\\,[a-z]+$/,\n\trdash = /^\\-/,\n\trddash = /^\\-\\-/,\n\tristarget = /^[^\\-]/,\n\tSCRIPT_NAME = ( process.argv[ 1 ] || '' ).split( '/' ).pop(),\n\thelpOption = {\n\t\tname: 'help',\n\t\tshort: 'h',\n\t\ttype: function(){ return true; },\n\t\tdescription: 'Displays help information about this script',\n\t\texample: \"'\" + SCRIPT_NAME + \" -h' or '\" + SCRIPT_NAME + \" --help'\",\n\t\tonset: function( args ) {\n\t\t\tself.help( args.mod );\n\t\t\tprocess.exit( 0 );\n\t\t}\n\t},\n\tboolTest = function( value ) {\n\t\treturn value == 'true' || value == 'false' || value == '1' || value == '0';\n\t},\n\tself;\n\n// argv module\nmodule.exports = self = {\n\n\t// Default script name\n\tname: SCRIPT_NAME,\n\n\t// Default description to the triggered script 'node script'\n\tdescription: 'Usage: ' + SCRIPT_NAME + ' [options]',\n\n\t// Modules\n\tmods: {},\n\n\t// Shorthand options\n\tshort: { h: helpOption },\n\n\t// Options\n\toptions: { help: helpOption },\n\n\t// List of common types\n\ttypes: {\n\n\t\tstring: function( value ) {\n\t\t\treturn value.toString();\n\t\t},\n\n\t\tpath: function( value ) {\n\t\t\tvar end = value[ value.length - 1 ] == '/';\n\n\t\t\tif ( rhome.exec( value ) ) {\n\t\t\t\tvalue = PATH.normalize( process.env.HOME + '/' + value.replace( rhome, '' ) );\n\t\t\t}\n\t\t\telse if ( ! rroot.exec( value ) ) {\n\t\t\t\tvalue = PATH.normalize( process.cwd() + '/' + value );\n\t\t\t}\n\n\t\t\treturn value + ( end && value[ value.length - 1 ] != '/' ? '/' : '' );\n\t\t},\n\n\t\t'int': function( value ) {\n\t\t\treturn parseInt( value, 10 );\n\t\t},\n\n\t\t'float': function( value ) {\n\t\t\treturn parseFloat( value, 10 );\n\t\t},\n\n\t\t'boolean': function( value ) {\n\t\t\treturn ( value == 'true' || value === '1' );\n\t\t},\n\n\t\tlist: function( value, name, options ) {\n\t\t\tif ( ! options[ name ] ) {\n\t\t\t\toptions[ name ] = [];\n\t\t\t}\n\n\t\t\toptions[ name ].push( value );\n\t\t\treturn options[ name ];\n\t\t},\n\n\t\tcsv: function( value ) {\n\t\t\treturn value.split( ',' );\n\t\t},\n\n\t\t'listcsv-combo': function( type ) {\n\t\t\tvar parts = type.split( ',' ),\n\t\t\t\tprimary = parts.shift(),\n\t\t\t\tsecondary = parts.shift();\n\n\t\t\treturn function( value, name, options, args ) {\n\t\t\t\t// Entry is going to be an array\n\t\t\t\tif ( ! options[ name ] ) {\n\t\t\t\t\toptions[ name ] = [];\n\t\t\t\t}\n\n\t\t\t\t// Channel to csv or list\n\t\t\t\tif ( primary == 'csv' ) {\n\t\t\t\t\tvalue.split( ',' ).forEach(function( val ) {\n\t\t\t\t\t\toptions[ name ].push( self.types[ secondary ]( val, name, options, args ) );\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toptions[ name ].push( self.types[ secondary ]( value, name, options, args ) );\n\t\t\t\t}\n\n\t\t\t\treturn options[ name ];\n\t\t\t};\n\t\t}\n\n\t},\n\n\t// Creates custom type function\n\ttype: function( name, callback ) {\n\t\tif ( self.isObject( name ) ) {\n\t\t\tfor ( var i in name ) {\n\t\t\t\tif ( self.isFunction( name[ i ] ) ) {\n\t\t\t\t\tself.types[ i ] = name[ i ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( callback === undefined ) {\n\t\t\treturn self.types[ name ];\n\t\t}\n\t\telse if ( self.isFunction( callback ) ) {\n\t\t\tself.types[ name ] = callback;\n\t\t}\n\t\telse if ( callback === null && self.types.hasOwnProperty( name ) ) {\n\t\t\tdelete self.types[ name ];\n\t\t}\n\n\t\treturn self;\n\t},\n\n\t// Setting version number, and auto setting version option\n\tversion: function( v ) {\n\t\tself.option({\n\t\t\t_version: v,\n\t\t\tname: 'version',\n\t\t\ttype: function(){ return true; },\n\t\t\tdescription: 'Displays version info',\n\t\t\texample: self.name + \" --version\",\n\t\t\tonset: function( args ) {\n\t\t\t\tconsole.log( v + \"\\n\" );\n\t\t\t\tprocess.exit( 0 );\n\t\t\t}\n\t\t});\n\n\t\treturn self;\n\t},\n\n\t// Adding options to definitions list\n\toption: function( mod, object ) {\n\t\tif ( object === undefined ) {\n\t\t\tobject = mod;\n\t\t\tmod = undefined;\n\t\t}\n\n\t\t// Iterate over array for multi entry\n\t\tif ( self.isArray( object ) ) {\n\t\t\tobject.forEach(function( entry ) {\n\t\t\t\tself.option( mod, entry );\n\t\t\t});\n\t\t}\n\t\t// Handle edge case\n\t\telse if ( ! self.isObject( object ) ) {\n\t\t\tthrow new Error( 'No option definition provided' + ( mod ? ' for module ' + mod : '' ) );\n\t\t}\n\t\t// Handle module definition\n\t\telse if ( object.mod ) {\n\t\t\tself.mod( object );\n\t\t}\n\t\t// Correct the object\n\t\telse {\n\t\t\tif ( ! object.name ) {\n\t\t\t\tthrow new Error( 'No name provided for option' );\n\t\t\t}\n\t\t\telse if ( ! object.type ) {\n\t\t\t\tthrow new Error( 'No type proveded for option' );\n\t\t\t}\n\n\t\t\t// Attach tester for value on booleans\n\t\t\t// to avoid false targets\n\t\t\tobject.test = object.test || ( object.type == 'boolean' ? boolTest : null );\n\t\t\tobject.description = object.description || '';\n\t\t\tobject.type = self.isFunction( object.type ) ? object.type :\n\t\t\t\tself.isString( object.type ) && rlistcsv.exec( object.type ) ? self.types[ 'listcsv-combo' ]( object.type ) :\n\t\t\t\tself.isString( object.type ) && self.types[ object.type ] ? self.types[ object.type ] :\n\t\t\t\tself.types.string;\n\n\t\t\t// Apply to module\n\t\t\tif ( mod ) {\n\t\t\t\tif ( ! self.mods[ mod ] ) {\n\t\t\t\t\tself.mods[ mod ] = { mod: mod, options: {}, short: {} };\n\t\t\t\t}\n\n\t\t\t\t// Attach option to submodule\n\t\t\t\tmod = self.mods[ mod ];\t\n\t\t\t\tmod.options[ object.name ] = object;\n\n\t\t\t\t// Attach shorthand\n\t\t\t\tif ( object.short ) {\n\t\t\t\t\tmod.short[ object.short ] = object;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Apply to root options\n\t\t\telse {\n\t\t\t\tself.options[ object.name ] = object;\n\n\t\t\t\t// Attach shorthand option\n\t\t\t\tif ( object.short ) {\n\t\t\t\t\tself.short[ object.short ] = object;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn self;\n\t},\n\n\t// Creating module\n\tmod: function( object ) {\n\t\tvar mod;\n\n\t\t// Allow multi mod setup\n\t\tif ( self.isArray( object ) ) {\n\t\t\tobject.forEach(function( value ) {\n\t\t\t\tself.mod( value );\n\t\t\t});\n\t\t}\n\t\t// Handle edge case\n\t\telse if ( ! self.isObject( object ) ) {\n\t\t\tthrow new Error( 'No mod definition provided' );\n\t\t}\n\t\t// Force mod name\n\t\telse if ( ! object.mod ) {\n\t\t\tthrow new Error( \"Expecting 'mod' entry for module\" );\n\t\t}\n\t\t// Create object if not already done so\n\t\telse if ( ! self.mods[ object.mod ] ) {\n\t\t\tself.mods[ object.mod ] = { mod: object.mod, options: {}, short: {} };\n\t\t}\n\n\t\t// Setup\n\t\tmod = self.mods[ object.mod ];\n\t\tmod.description = object.description || mod.description;\n\n\t\t// Attach each option\n\t\tself.option( mod.mod, object.options );\n\n\t\treturn self;\n\t},\n\n\t// Cleans out current options\n\tclear: function(){\n\t\tvar version = self.options.version;\n\n\t\t// Clean out modes and reapply help option\n\t\tself.short = {};\n\t\tself.options = {};\n\t\tself.mods = {};\n\t\tself.option( helpOption );\n\n\t\t// Re-apply version if set\n\t\tif ( version ) {\n\t\t\tself.option( version );\n\t\t}\n\n\t\treturn self;\n\t},\n\n\t// Description setup\n\tinfo: function( mod, description ) {\n\t\tif ( description === undefined ) {\n\t\t\tself.description = mod;\n\t\t}\n\t\telse if ( self.mods[ mod ] ) {\n\t\t\tself.mods[ mod ] = description;\n\t\t}\n\n\t\treturn self;\n\t},\n\n\t// Prints out the help doc\n\thelp: function( mod ) {\n\t\tvar output = [], name, option;\n\n\t\t// Printing out just a module's definitions\n\t\tif ( mod && ( mod = self.mods[ mod ] ) ) {\n\t\t\toutput = [ '', mod.description, '' ];\n\n\t\t\tfor ( name in mod.options ) {\n\t\t\t\toption = mod.options[ name ];\n\n\t\t\t\toutput.push( \"\\t--\" +option.name + ( option.short ? ', -' + option.short : '' ) );\n\t\t\t\toutput.push( \"\\t\\t\" + option.description );\n\t\t\t\tif ( option.example ) {\n\t\t\t\t\toutput.push( \"\\t\\t\" + option.example );\n\t\t\t\t}\n\n\t\t\t\t// Spacing\n\t\t\t\toutput.push( \"\" );\n\t\t\t}\n\t\t}\n\t\t// Printing out just the root options\n\t\telse {\n\t\t\toutput = [ '', self.description, '' ];\n\n\t\t\tfor ( name in self.options ) {\n\t\t\t\toption = self.options[ name ];\n\n\t\t\t\toutput.push( \"\\t--\" +option.name + ( option.short ? ', -' + option.short : '' ) );\n\t\t\t\toutput.push( \"\\t\\t\" + option.description );\n\t\t\t\tif ( option.example ) {\n\t\t\t\t\toutput.push( \"\\t\\t\" + option.example );\n\t\t\t\t}\n\n\t\t\t\t// Spacing\n\t\t\t\toutput.push( \"\" );\n\t\t\t}\n\t\t}\n\n\t\t// Print out the output\n\t\tconsole.log( output.join( \"\\n\" ) + \"\\n\\n\" );\n\t\treturn self;\n\t},\n\n\t// Runs the arguments parser\n\t_run: function( argv ) {\n\t\tvar args = { targets: [], options: {} },\n\t\t\topts = self.options,\n\t\t\tshortOpts = self.short,\n\t\t\tskip = false;\n\n\t\t// Allow for passing of arguments list\n\t\targv = self.isArray( argv ) ? argv : process.argv.slice( 2 );\n\n\t\t// Switch to module's options when used\n\t\tif ( argv.length && ristarget.exec( argv[ 0 ] ) && self.mods[ argv[ 0 ] ] ) {\n\t\t\targs.mod = argv.shift();\n\t\t\topts = self.mods[ args.mod ].options;\n\t\t\tshortOpts = self.mods[ args.mod ].short;\n\t\t}\n\n\t\t// Iterate over arguments\n\t\targv.forEach(function( arg, i ) {\n\t\t\tvar peek = argv[ i + 1 ], option, index, value;\n\n\t\t\t// Allow skipping of arguments\n\t\t\tif ( skip ) {\n\t\t\t\treturn ( skip = false );\n\t\t\t}\n\t\t\t// Full option '--option'\n\t\t\telse if ( rddash.exec( arg ) ) {\n\t\t\t\targ = arg.replace( rddash, '' );\n\n\t\t\t\t// Default no value to true\n\t\t\t\tif ( ( index = arg.indexOf( '=' ) ) !== -1 ) {\n\t\t\t\t\tvalue = arg.substr( index + 1 );\n\t\t\t\t\targ = arg.substr( 0, index );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = 'true';\n\t\t\t\t}\n\n\t\t\t\t// Be strict, if option doesn't exist, throw and error\n\t\t\t\tif ( ! ( option = opts[ arg ] ) ) {\n\t\t\t\t\tthrow \"Option '--\" + arg + \"' not supported\";\n\t\t\t\t}\n\n\t\t\t\t// Send through type converter\n\t\t\t\targs.options[ arg ] = option.type( value, arg, args.options, args );\n\n\t\t\t\t// Trigger onset callback when option is set\n\t\t\t\tif ( self.isFunction( option.onset ) ) {\n\t\t\t\t\toption.onset( args );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Shorthand option '-o'\n\t\t\telse if ( rdash.exec( arg ) ) {\n\t\t\t\targ = arg.replace( rdash, '' );\n\n\t\t\t\tif ( arg.length > 1 ) {\n\t\t\t\t\targ.split( '' ).forEach(function( character ) {\n\t\t\t\t\t\tif ( ! ( option = shortOpts[ character ] ) ) {\n\t\t\t\t\t\t\tthrow \"Option '-\" + character + \"' not supported\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\targs.options[ option.name ] = option.type( 'true', option.name, args.options, args );\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Ensure that an option exists\n\t\t\t\t\tif ( ! ( option = shortOpts[ arg ] ) ) {\n\t\t\t\t\t\tthrow \"Option '-\" + arg + \"' not supported\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check next option for target association\n\t\t\t\t\tif ( peek && option.test && option.test( peek, option.name, args.options, args ) ) {\n\t\t\t\t\t\tvalue = peek;\n\t\t\t\t\t\tskip = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( peek && ! option.test && ristarget.exec( peek ) ) {\n\t\t\t\t\t\tvalue = peek;\n\t\t\t\t\t\tskip = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = 'true';\n\t\t\t\t\t}\n\n\t\t\t\t\t// Convert it\n\t\t\t\t\targs.options[ option.name ] = option.type( value, option.name, args.options, args );\n\n\t\t\t\t\t// Trigger onset callback when option is set\n\t\t\t\t\tif ( self.isFunction( option.onset ) ) {\n\t\t\t\t\t\toption.onset( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Targets\n\t\t\telse {\n\t\t\t\targs.targets.push( arg );\n\t\t\t}\n\t\t});\n\n\t\treturn args;\n\t},\n\n\trun: function( argv ) {\n\t\ttry {\n\t\t\treturn self._run( argv );\n\t\t}\n\t\tcatch ( e ) {\n\t\t\tif ( ! self.isString( e ) ) {\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\tconsole.log( \"\\n\" + e + \". Trigger '\" + self.name + \" -h' for more details.\\n\\n\" );\n\t\t\tprocess.exit( 1 );\n\t\t}\n\t}\n\n};\n\n\n// Type tests\n\"Boolean Number String Function Array Date RegExp Object Error\".split(' ').forEach(function( method ) {\n\tif ( method == 'Array' ) {\n\t\treturn ( self.isArray = Array.isArray );\n\t}\n\telse if ( method == 'Error' ) {\n\t\tself.isError = function( object ) {\n\t\t\treturn object && ( object instanceof Error );\n\t\t};\n\n\t\treturn;\n\t}\n\n\tvar match = '[object ' + method + ']';\n\tself[ 'is' + method ] = function( object ) {\n\t\treturn object !== undefined && object !== null && toString.call( object ) == match;\n\t};\n});\n","import * as fs from \"fs\";\r\nimport * as path from \"path\";\r\nimport * as argvParser from \"argv\";\r\nimport { ICLIConfig } from \"./ICLIConfig\";\r\nimport { loadActions } from \"./loadActions\";\r\n\r\nconst configPath = path.join(process.cwd(), \"vladnet.json\");\r\n\r\ntry {\r\n    const config = <ICLIConfig>JSON.parse(fs.readFileSync(configPath).toString());\r\n    const actions = loadActions(config);\r\n    const command = process.argv[2];\r\n    const action = actions[command];\r\n    argvParser.option(action.options);\r\n    const result = argvParser.run(process.argv.slice(3));\r\n    action.run(result.options);\r\n}\r\ncatch(err) {\r\n    console.error(`Error reading config by path \"${configPath}\"`, err.stack);\r\n}\r\n","import nativeRequire from \"../nativeRequire\";\r\nimport { ICLIConfig } from \"./ICLIConfig\";\r\nimport { ICliAction } from \"../ICLIAction\";\r\nimport { normalizePaths } from \"./normalizePaths\";\r\n\r\nexport const loadActions = (config: ICLIConfig) => {\r\n    const absoluteActionPaths = normalizePaths(config.actions);\r\n\r\n    const actions = absoluteActionPaths.reduce((acc, actionPath, i) => {\r\n        let loadedActions: any;\r\n\r\n        try {\r\n            loadedActions = nativeRequire(actionPath);\r\n        }\r\n        catch(err) {\r\n            console.error(`[vladnet] Error while reading ${config.actions[i]}\\n`, err.stack, \"\\n\");\r\n        }\r\n\r\n        if (loadActions) {\r\n            Object\r\n                .keys(loadedActions.actions)\r\n                .forEach(key => {\r\n                    acc[key] = loadedActions.actions[key];\r\n                });\r\n        }\r\n\r\n        return acc;\r\n    }, {} as { [key: string]: ICliAction });\r\n\r\n    return actions;\r\n}","import * as path from \"path\";\r\n\r\nexport const normalizePaths = (paths: string[]) => {\r\n    return paths.map(value => {\r\n        if (value.charAt(0) === \".\") value = path.join(process.cwd(), value);\r\n        return value;\r\n    });\r\n};\r\n","declare var __webpack_require__: Function;\r\ndeclare var __non_webpack_require__: Function;\r\nexport default (typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require);\r\n","module.exports = require(\"fs\");","module.exports = require(\"path\");"],"sourceRoot":""}